#!/bin/bash
# Парсер acceess.log NGINX
# Вешаем блокировку на повторный запуск и на принудительное завершение скрипта
lockfile=./mylockfile
if ( set -o noclobber; echo "$$" > "$lockfile") 2> /dev/null
then
    trap 'echo Dont stop me now' INT
    # подчищаем блок файл после окончания работы скрипта для запуска скрипта по рассписанию
    trap 'rm -f "$lockfile"; exit $?' TERM EXIT
    # Создаем временный файл, в который помещаются строки исходного access.log занесенные с момента последного срабатывания скрипта 
    touch temp.log
    # Создаем временный файл, в котором формируется cообщение для отправки
    touch mail.log
    # считываем в переменную временную метку (в секундах) последнего запуска скрипта из файла time.log
    lastold=$(cat time.log)
    # получаем отметку времени (в секундах) последней строки access.log файла и записываем полученную отметку в time.log для последующих запусков
    tail -n1 access-4560-644067.log|awk -F'[][]' '{ gsub(/\//," ",$2); sub(/:/," ",$2); "date +%s -d \""$2"\""|getline d; print d;}' > time.log
    # выписываем строки access.log файла c момента последнего запуска скрипта в временный файл temp.log
    awk -F'[][]' -v last=$lastold '{ gsub(/\//," ",$2); sub(/:/," ",$2); "date +%s -d \""$2"\""|getline d; if (last<d)print $0 }' access-4560-644067.log > temp.log
    # Помещаем в переменную начало временного диапазона, который подвергается обработке
    timeup=$(awk 'FNR==1 {print $4 " " $5 " " $6 " " $7}' temp.log)
    # Помещаем в переменную конец временного диапазона, который подвергается обработке
    timedown=$(tail -n1 temp.log | awk '{print $4 " " $5 " " $6 " " $7}')
    # Помещаем в временный файл mail.log информацию о обрабатываемом временном диапазоне
    echo "Обрабатываемый временной диапазон c " $timeup " по " $timedown > mail.log
    # Фрмируем список 5-ти IP адресов с наибольшим кол-вом запросов c момента последнего запуска скрипта и помещаем данные в временный файл mail.log
    echo "Список 5-ти IP адресов (с наибольшим кол-вом запросов) c момента последнего запуска скрипта (формат вывода колл-во/IP адрес)" >> mail.log
    cat temp.log | awk '{print $1}' | sort -n | uniq -c | sort -nr | head -n5 >> mail.log
    # Фрмируем список 5-ти запрашиваемых URL с наибольшим кол-вом запросов c момента последнего запуска скрипта и помещаем данные в временный файл mail.log
    echo "Список 5-ти запрашиваемых URL (с наибольшим кол-вом запросов) c момента последнего запуска скрипта (формат вывода колл-во/URL)" >> mail.log
    cat temp.log | awk 'BEGIN { FS = "\"" } ; {print $2}'| awk '{print $2}' | sort -n | uniq -c | sort -nr | head -n5 >> mail.log
    # Фрмируем список ошибок веб-сервера/приложения c момента последнего запуска скрипта и помещаем данные в временный файл mail.log
    echo "Ошибки веб-сервера/приложения c момента последнего запуска скрипта" >> mail.log
    cat temp.log | awk 'BEGIN { FS = "\" "; OFS= "#"} ; {print $0,$2}' | awk 'BEGIN { FS = "#" }; { if (!(match($2,/2.*/))) { print $1 }}' >> mail.log
    # Фрмируем список всех кодов HTTP ответа с указанием их кол-ва c момента последнего запуска скрипта и помещаем данные в временный файл mail.log
    echo "Список всех кодов HTTP ответа с указанием их кол-ва с момента последнего запуска скрипта (формат вывода колл-во/код HTTP ответа)" >> mail.log
    cat temp.log | awk 'BEGIN { FS = "\"" } ; {print $3}'| awk '{print $1}' | sort -n | uniq -c | sort -nr >> mail.log
    # производим отправку подготовленных данных на указанный Email (при условии настроенного Postfix на серврер)
    mail.log | mail -s "Message Subject" otus2023@example.ru
    # удаляем временные файлы
    rm temp.log
    rm mail.log
else
    # выводим сообщение при попытке одновременного запуска еще одной копии скрипта
    echo "Failed to acquire lockfile: $lockfile."
    echo "Held by $(cat $lockfile)"
fi